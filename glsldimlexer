%class-header="include/dim/scanner.hpp"
%baseclass-header="include/dim/scannerbase.hpp"
%lex-source="src/lex.cpp"
%implementation-header="src/scanner.ih"
%namespace=dim

%x string include comment1 comment2

%%

// shader stages
^[ \t]*%-vertex-shader        return Token::vertex;
^[ \t]*%-fragment-shader      return Token::fragment;
^[ \t]*%-geometry-shader      return Token::geometry;
^[ \t]*%-tess-control-shader  return Token::tessControl;
^[ \t]*%-tess-eval-shader     return Token::tessEval;
^[ \t]*%-compute-shader       return Token::compute;

// preprocessor directives
^[ \t]*#version[ \t]*         return Token::version;

^[ \t]*#include               begin(StartCondition__::include);          

<include>{
  [ \t]*\"                    begin(StartCondition__::string);
}

<string>{
  \"                          {
                                begin(StartCondition__::INITIAL); 
                                size_t quotePos = matched().find_last_of('\"');
                                
                                setMatched(matched().substr(0, quotePos));
                                
                                std::string path = filename().substr(0, filename().find_last_of('/') + 1);

                                pushStream(path + matched());
                                return Token::include;
                              }
                  
  \\.|.                       more();
}

// comments
"/*"                          begin(StartCondition__::comment1);

<comment1>{
  "*/"                        begin(StartCondition__::INITIAL);
  \\.|.                       //more();
  \n                          return Token::whitespace;
}

//"//"[\\..]*\n                 return Token::whitespace;//         
//"//"(\\.|.)*\n                return Token::whitespace;
"//"                          begin(StartCondition__::comment2);
<comment2>{
  \n                          {
                                begin(StartCondition__::INITIAL);
                                return Token::whitespace;
                              }
  \\.|.                       
}                 

// end of file
<INITIAL,string,comment1,comment2><<EOF>>    	  {
                                if(popStream())
                                  return Token::endOfFile;
                                else
                                  return 0;
                              }
			 
// regular GLSL               
layout                        return Token::layout;
location                      return Token::location;

in                            |
attribute                     return Token::in;
out                           return Token::out;

[0-9]*                        return Token::number;
dim_vertex                    {setMatched("0"); return Token::number;}
dim_normal                    {setMatched("1"); return Token::number;}
dim_texCoord                  {setMatched("2"); return Token::number;}
dim_binormal                  {setMatched("3"); return Token::number;}
dim_tangent                   {setMatched("4"); return Token::number;}
dim_instance                  {setMatched("5"); return Token::number;}

[a-zA-Z_][a-zA-Z0-9_]*        return Token::identifier;

[^ \t\n]                      return matched()[0];
[ \t\n]                       return Token::whitespace;

                              
